Suppose that the hash table has b buckets. In linear open addressing the buckets are examined in the order (f(k)+i) % b, 0 <= i < b, where k is the key of the element being searched for. In random probing a pseudo-random number generator is used to obtain a random sequence R(i), 1 <= i < b where R(1), R(2), ... R(b-1) is a permutation of [1, 2, ..., b-1]. The buckets are examined in the order f(k), (f(k)+R(i)) % b, 1 <= i < b.
As with double hashing, random hashing avoids clustering by making the probe sequence depend on the key
With random hashing, the probe sequence is generated by the output of a pseudorandom number generator seeded by the key (possibly together with another seed component that is the same for every key, but is different for different tables)
The insert algorithm for random hashing is then:

1. Create RNG seeded with K. Set indx = RNG.next() mod M.
2. If table location indx already contains the key, no need to insert it. Done!
3. Else if table location indx is empty, insert key there. Done!
4. Else collision. Set indx = RNG.next() mod M.
5. If all M locations have been probed, give up. Else, go to 2.
Random hashing is easy to analyze, but because of the "expense" of random number generation, it is not often used; double hashing works about as well