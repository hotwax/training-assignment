#include <bits/stdc++.h>
using namespace std;

// Creating HashMap with quadratic Probing

// Quadratic probing is an open-addressing scheme where we look for the i2‘th
// slot in the i’th iteration if the given hash value x collides in the hash table.

// hash Node Class

class HashNode
{
public:
    int value;
    int key;

    HashNode(int key, int value)
    {
        this->key = key;
        this->value = value;
    }
};

// HashMap Class

class HashMap
{

    // Hash elements array

    HashNode **arr;

    // hash capacity

    int capacity;

    // size
    int size;

    // counting collisions

    int collisions;

public:
    // Constructor
    HashMap(int capacity)
    {
        this->capacity = capacity;
        size = 0;
        collisions = 0;
        // creating hashNode array
        arr = new HashNode *[capacity];

        // initializing all values with NULL

        for (int i = 0; i < capacity; i++)
        {
            arr[i] = NULL;
        }
    }

    // print function

    void print(string message)
    {
        cout << endl
             << message;
    }

    // hash function to find index for a key

    int hashCode(int key)
    {
        return key % capacity;
    }

    // function for value insertion --

    void insertNode(int key, int value)
    {
        HashNode *temp = new HashNode(key, value);

        int hashIndex = hashCode(key);

        // storing the first index generated by hash function for use in quadratic probing

        int firstHashIndex = hashIndex;

        // finding the free space
        // bool if collision detected
        bool collisionExist = false;

        // Using Quadratic Probing

        // creating count variable for quadratic increasing the index

        int count = 1;

        while (arr[hashIndex] != NULL && arr[hashIndex]->key != key)
        {
            collisionExist = true;
            // incrementing hashIndex and again making a hashcode for indexing
            hashIndex = (firstHashIndex + (count * count)) % capacity;
            count++;
        }

        if (collisionExist)
        {
            this->collisions++;
        }

        if (arr[hashIndex] == NULL)
        {
            // increasing the size of HashMap
            size++;
            arr[hashIndex] = temp;
        }

        // updating the value on particular key

        if (arr[hashIndex]->key == key)
        {
            arr[hashIndex]->value = value;
        }
    }

    // switch case function for insertion

    void insertForMenu()
    {
        // taking Input

        int key;
        print("Enter the Key: ");
        cin >> key;
        int value;
        print("Enter the value: ");
        cin >> value;

        insertNode(key, value);
    }

    // for deleting a key value pair

    int deleteNode(int key)
    {
        int hashIndex = hashCode(key);

        // storing first hashIndex

        int firstHashIndex = hashIndex;

        // count variable for sqauring

        int count = 1;

        // finding the node

        while (arr[hashIndex] != NULL)
        {
            if (arr[hashIndex]->key == key)
            {
                // removing the key value pair node
                HashNode *temp = arr[hashIndex];

                arr[hashIndex] = NULL;

                // decrementing size
                size--;

                return temp->value;
            }
            else
            {
                // if not found

                // using quadratic probing

                hashIndex = (firstHashIndex + (count * count)) % capacity;
                count++;
            }
        }
        cout << "endl"
             << "Key Not Found.";
        return 0;
    }

    // void function for deleting

    void deleteNodeVoid()
    {
        // Taking input from the user

        int key;
        print("Enter the Key: ");
        cin >> key;

        print("The key deleted with value : ");
        cout << deleteNode(key);
    }

    int getValueInMap(int key)
    {
        int hashIndex = hashCode(key);
        // checking if loop does not exeed the size
        int count = 0;

        // variable for first hashIndex

        int firstHashIndex = hashIndex;

        // for sqauring in quadratic probing

        int multiplier = 1;

        // finding the key for value

        while (arr[hashIndex] != NULL && count < capacity)
        {
            if (arr[hashIndex]->key == key)
            {
                return arr[hashIndex]->value;
            }

            hashIndex = (firstHashIndex + (multiplier * multiplier)) % capacity;
            count++;
        }
        cout << endl
             << "Key Not found.";
        return 0;
    }

    // void get value

    void getValue()
    {
        // taking Input from the user

        int key;
        print("Enter the key to find the value: ");
        cin >> key;

        print("Value is : ");
        cout << getValueInMap(key);
    }

    // Getting a size

    int sizeOfMap()
    {
        return size;
    }

    // void function to get a size so that it does not return something menu can run soomthly

    void getSize()
    {
        print("The size of Map is : ");
        cout << sizeOfMap();
    }

    void display()
    {
        //			cout<<endl<<"Your HashMap -- ";
        cout << endl;
        for (int i = 0; i < capacity; i++)
        {
            cout << i << " -- ";
            if (arr[i] != NULL)
            {
                cout << arr[i]->key << " -> " << arr[i]->value;
            }
            cout << endl;
        }
    }

    // function to see collision

    void seeCollision()
    {
        cout << this->collisions;
    }
};

// Print function

void print(string message)
{
    cout << endl
         << message;
}

int main()
{

    int capacity;
    print("Enter the capacity for which the key will be moded to and array will crested on this - ");
    cin >> capacity;
    HashMap map(capacity);

    // while for menu --

    while (true)
    {
        print("Collisions - ");
        map.seeCollision();
        print("Your Hash Map -- ");
        map.display();

        cout << endl;

        print("Enter 1 for Add Key Value operation");
        print("Enter 2 for Delete with key operation");
        print("Enter 3 for Size of Map operation");
        print("Enter 4 for Get value From Map operation");

        print("Enter 5 to exit");
        cout << endl;
        int input;
        cin >> input;
        int data;

        switch (input)
        {
        case 1:
            map.insertForMenu();
            break;
        case 2:
            map.deleteNodeVoid();
            break;
        case 3:
            map.getSize();
            break;
        case 4:
            map.getValue();
            break;

        default:
            return 0;
        }
    }
}